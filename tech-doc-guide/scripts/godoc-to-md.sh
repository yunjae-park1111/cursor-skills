#!/bin/bash
# godoc-to-md.sh - godoc 기반 패키지 문서 자동 생성 (범용)
# gomarkdoc 출력을 tech-doc-guide 스킬 형식(프로세스/구조 Spec)으로 변환
#
# 사용법:
#   godoc-to-md.sh <프로젝트_루트> <문서_디렉토리> [옵션]
#
# 필수 인자:
#   프로젝트_루트    Go 프로젝트 루트 디렉토리
#   문서_디렉토리    마크다운 문서 출력 디렉토리
#
# 옵션:
#   -f, --filter PATTERN   패키지 부분 매칭 필터 (예: client, internal)
#
# 예시:
#   godoc-to-md.sh . ./docs
#   godoc-to-md.sh . ./docs -f internal/agent
#   godoc-to-md.sh /path/to/project /path/to/project/docs

set -euo pipefail

GOPATH_BIN="$(go env GOPATH 2>/dev/null)/bin"
[[ -d "$GOPATH_BIN" ]] && export PATH="${PATH}:${GOPATH_BIN}"

if [[ $# -lt 2 ]]; then
  echo "error: 필수 인자 부족"
  echo "사용법: godoc-to-md.sh <프로젝트_루트> <문서_디렉토리>"
  exit 1
fi

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# 상대경로는 스크립트 파일 기준, 절대경로는 그대로
resolve() { [[ "$1" = /* ]] && echo "$1" || echo "$SCRIPT_DIR/$1"; }

get_repo_name() {
  local url
  url="$(git -C "$1" remote get-url origin 2>/dev/null)" || return 1
  echo "$url" | sed -E 's#.*(github\.com[:/])##; s/\.git$//'
}

PROJECT_ROOT="$(cd "$(resolve "$1")" && pwd)"; shift
OUT_DIR="$(mkdir -p "$(resolve "$1")" && cd "$(resolve "$1")" && pwd)"; shift
FILTER=""
REPO_NAME="$(get_repo_name "$PROJECT_ROOT" || echo "")"

while [[ $# -gt 0 ]]; do
  case "$1" in
    -f|--filter) FILTER="$2"; shift 2 ;;
    -*) echo "error: unknown option $1"; exit 1 ;;
    *)  FILTER="$1"; shift ;;
  esac
done

cd "$PROJECT_ROOT"

command -v gomarkdoc >/dev/null 2>&1 || {
  echo "error: gomarkdoc not found. install: go install github.com/princjef/gomarkdoc/cmd/gomarkdoc@latest"
  exit 1
}

# 패키지 자동 탐색 (vendor, testdata, cmd 제외)
PACKAGES=()
while IFS= read -r line; do
  PACKAGES+=("$line")
done < <(
  find . -name "*.go" \
    -not -path "*/vendor/*" \
    -not -path "*/testdata/*" \
    -not -path "*/cmd/*" \
    -not -path "*/api/*" \
    -not -path "*/docs/*" \
    -print0 \
    | xargs -0 grep -l "^package " \
    | sed 's|^\./||;s|/[^/]*$||' \
    | sort -u
)

if [[ ${#PACKAGES[@]} -eq 0 ]]; then
  echo "error: no Go packages found"
  exit 1
fi

# 공통 prefix 계산 (internal/agent/*, internal/shared/* → internal/)
common_prefix() {
  local prefix="${PACKAGES[0]}"
  for p in "${PACKAGES[@]}"; do
    while [[ "$p" != "$prefix"* ]]; do
      [[ "$prefix" != */* ]] && prefix="" && break
      prefix="${prefix%/*}"
    done
    [[ -z "$prefix" ]] && break
  done
  [[ -n "$prefix" ]] && echo "${prefix}/" || echo ""
}

PREFIX=$(common_prefix)

# 영어 heading → 한글 heading 매핑
heading_map() {
  sed -E \
    -e 's/^### /## /' \
    -e 's/^## File Structure$/## 파일 구조/' \
    -e 's/^## Components$/## 구성 요소/' \
    -e 's/^## Configuration$/## 설정/' \
    -e 's/^## Usage$/## 사용 예시/' \
    -e 's/^## Overview$/## 개요/' \
    -e 's/^## Architecture$/## 아키텍처/' \
    -e 's/^## Shutdown$/## 종료/' \
    -e 's/^## Message Flow$/## 메시지 흐름/' \
    -e 's/^## Connection Flow$/## 연결 흐름/' \
    -e 's/^## Error Handling$/## 에러 처리/' \
    -e 's/^## Reconnection$/## 재연결/' \
    -e 's/^## Protocol Handlers$/## 프로토콜 핸들러/'
}

# 앵커 링크 제거 (Notion 미지원): [Text](<#Anchor>) → Text, \[Text\](#anchor) → Text
remove_anchor_links() {
  perl -pe 's/\[([^\]]+)\]\(<#[^>]+>\)/$1/g; s/\\?\[([^\]]+)\\?\]\(#[^)]+\)/$1/g'
}

# gomarkdoc 이스케이프 제거 (Notion에서 그대로 노출됨): \( → (, \) → ), \[ → [, \- → -
unescape_markdown() {
  perl -pe 's/\\\\\\([()[\]\-])/$1/g; s/\\([()[\]\-])/$1/g'
}

# import 블록 제거
remove_import() {
  awk '
    /^```go$/ {
      hold = $0
      if ((getline line) > 0) {
        if (line ~ /^import /) {
          while ((getline line) > 0) { if (line ~ /^```$/) break }
          next
        } else {
          print hold
          print line
          next
        }
      }
    }
    { print }
  '
}

# 첫 문단 앞에 "## 개요" 삽입
insert_overview() {
  local repo_line=""
  [[ -n "$REPO_NAME" ]] && repo_line="- **레포지토리**: \`${REPO_NAME}\`"
  awk -v repo="$repo_line" '
    BEGIN { found_title = 0; inserted = 0 }
    /^# / { found_title = 1; print; next }
    /^>/ { print; next }
    found_title && !inserted && /^[A-Z]/ {
      print ""
      print "## 개요"
      print ""
      if (repo != "") { print repo; print "" }
      inserted = 1
    }
    { print }
  '
}

# 패키지 경로 → 제목 (prefix 제거 후 capitalize)
make_title() {
  echo "$1" | sed "s|^${PREFIX}||" | awk -F/ '{
    for (i=1; i<=NF; i++) { printf "%s%s", toupper(substr($i,1,1)) substr($i,2), (i<NF ? " " : "\n") }
  }'
}

# 패키지 경로 → 출력 경로 (prefix 제거 후 .md)
make_output() {
  echo "$1" | sed "s|^${PREFIX}||;s|$|.md|"
}

generate() {
  local pkg_path="$1"
  local output
  output=$(make_output "$pkg_path")
  local title
  title=$(make_title "$pkg_path")

  mkdir -p "${OUT_DIR}/$(dirname "$output")"

  local raw
  raw=$(gomarkdoc "./${pkg_path}" 2>/dev/null) || {
    echo "  ✗ ${output} (gomarkdoc failed)"
    return 1
  }

  local import_path
  import_path=$(echo "$raw" | awk '/^```go$/{getline; if($0 ~ /^import "/){gsub(/^import "|"$/,"",$0); print; exit}}')

  echo "$raw" \
    | awk '/^## Index/{exit} {print}' \
    | { grep -v '^<!-- Code generated by gomarkdoc' || true; } \
    | remove_import \
    | heading_map \
    | remove_anchor_links \
    | unescape_markdown \
    | sed "1s|^# .*|# ${title}|" \
    | awk -v path="$import_path" '
        NR==1 { print; print ""; print "> \`" path "\` · godoc 기반 자동 생성"; next }
        { print }
      ' \
    | insert_overview \
    | cat -s \
    > "${OUT_DIR}/${output}"

  echo "  ✓ ${OUT_DIR}/${output}"
}

echo "=== godoc 문서 생성 (tech-doc-guide 형식) ==="
echo "  project: ${PROJECT_ROOT}/"
echo "  output:  ${OUT_DIR}/"
echo ""

count=0
for pkg_path in "${PACKAGES[@]}"; do
  if [[ -n "$FILTER" && "$pkg_path" != *"$FILTER"* ]]; then
    continue
  fi
  generate "$pkg_path"
  ((count++))
done

echo ""
echo "=== ${count}개 패키지 문서 생성 완료 ==="
